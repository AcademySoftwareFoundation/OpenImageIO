\chapter{{\kw oiiotool}: the OIIO Swiss Army Knife}
\label{chap:oiiotool}
\indexapi{oiiotool}

\section{Overview}


The \oiiotool program will read images (from any file format for which
an \ImageInput plugin can be found), perform various operations on them,
and write images (in any format for which an \ImageOutput plugin can be
found).

The \oiiotool utility is invoked as follows:

\medskip

\hspace{0.25in} \oiiotool \emph{args}

\medskip

\oiiotool maintains an \emph{image stack}, with the top image in the
stack also called the \emph{current image}.  The stack begins containing
no images.

\oiiotool arguments consist of image names, or commands.  When an
image name is encountered, that image is pushed on the stack and becomes
the new \emph{current image}.

Most other commands either alter the current image (replacing it with
the alteration), or in some cases will pull more than one image off the
stack (such as the current image and the next item on the stack) and
then push a new image.

\subsubsection*{Optional arguments}

Some commands stand completely on their own (like {\cf --flip}), others
take one or more arguments (like {\cf --resize} or {\cf -o}):

\smallskip
\hspace{0.25in} {\cf oiiotool foo.jpg --flip --resize 640x480 -o out.tif}
\smallskip

A few commands take optional modifiers for options that are so
rarely-used or confusing that they should not be required arguments.
In these cases, they are appended to the command name, after a colon
(``{\cf :}''), and with a \emph{name}{\cf =}\emph{value} format.  As
an example:

\smallskip
\hspace{0.25in} {\cf oiiotool --capture:camera=1 -o out.tif}
\smallskip

\subsubsection*{Frame sequences}

\NEW
It is also possible to have \oiiotool operate on numbered sequences of
images.  In effect, this will execute the \oiiotool command several
times, making substitutions to the sequence arguments in turn.

Image sequences are specified by having filename arguments to
oiiotool use either a numeric wildcard (designated by ``{\cf \#}'') or an
explicit numeric range (designated such as ``{\cf 1-10\#}''), or
spelling out a more complex pattern with {\cf --frames}.  For example:

\begin{code}
    oiiotool big.#.tif --resize 100x100 -o small.#.tif
\end{code}

\noindent If there are files {\cf big0001.tif}, {\cf big0002.tif}, and
{\cf big0003.tif}, will be the equivalent of having issued the following
sequence of commands:

\begin{code}
    oiiotool big.0001.tif --resize 100x100 -o small.0001.tif
    oiiotool big.0002.tif --resize 100x100 -o small.0002.tif
    oiiotool big.0003.tif --resize 100x100 -o small.0003.tif
\end{code}

\noindent The following is also equivalent:

\begin{code}
    oiiotool big.1-3#.tif --resize 100x100 -o small.1-3#.tif
\end{code}

You can also explicitly use the {\cf --frames} to specify a frame
sequence very flexibly as a sequence of comma-separated subsequences,
where each subsequence is a single frame (e.g., {\cf 100}), a range of
frames ({\cf 100-150}), or a frame range with step size ({\cf 100-150x4}).
An optional {\cf --framepadding} can be used to change the default number
of digits (with leading zeroes applied) that the frame numbers should
have.  It defaults to 4.
For example,
\begin{code}
    oiiotool --framepadding 3 --frames 3,4,10-20x2 blah.#.tif
\end{code}
\noindent would match {\cf blah.003.tif}, {\cf blah.004.tif},
{\cf blah.010.tif}, {\cf blah.012.tif}, 
{\cf blah.014.tif}, {\cf blah.016.tif}, {\cf blah.018.tif}, 
{\cf blah.020.tif}.


\section{\oiiotool Tutorial / Recipes}

This section will give quick examples of common uses of \oiiotool to get
you started.  They should be fairly intuitive, but you can read the
subsequent sections of this chapter for all the details on every
command.

\subsection*{Printing information about images}

To print the name, format, resolution, and data type of an image
(or many images):

\begin{code}
    oiiotool --info *.tif
\end{code}

\noindent To also print the full metadata about each input image, use both
{\cf --info} and {\cf -v}:

\begin{code}
    oiiotool --info -v *.tif
\end{code}

\noindent To print info about all subimages and/or MIP-map levels of each
input image, use the {\cf -a} flag:

\begin{code}
    oiiotool --info -v -a mipmap.exr
\end{code}

\noindent To print statistics giving the minimum, maximum, average, and
standard deviation of each channel of an image, as well as other
information about the pixels:

\begin{code}
    oiiotool --stats img_2012.jpg
\end{code}

\noindent The {\cf --info}, {\cf --stats}, {\cf -v}, and {\cf -a} flags may
be used in any combination.


\subsection*{Converting between file formats}

It's a snap to convert among image formats supported by \product
(i.e., for which \ImageInput and \ImageOutput plugins can be found).
The \oiiotool utility will simply infer the file format from the
file extension. The following example converts a PNG image to JPEG:

\begin{code}
    oiiotool lena.png -o lena.jpg
\end{code}

The first argument ({\cf lena.png}) is a filename, causing \oiiotool to
read the file and makes it the current image.  The {\cf -o} command
outputs the current image to the filename specified by the next
argument.

Thus, the above command should be read to mean, ``Read {\cf lena.png}
into the current image, then output the current image as {\cf lena.jpg}
(using whatever file format is traditionally associated with the {\cf
  .jpg} extension).''


\subsection*{Comparing two images}

To print a report of the differences between two images of the same
resolution:

\begin{code}
    oiiotool old.tif new.tif --diff
\end{code}

\noindent If you also want to save an image showing just the differences:

\begin{code}
    oiiotool old.tif new.tif --diff --sub --abs -o diff.tif
\end{code}

This looks complicated, but it's really simple: read {\cf old.tif},
read {\cf new.tif} (pushing {\cf old.tif} down on the image stack),
report the differences between them, subtract {\cf new.tif} from 
{\cf old.tif} and replace them both with the difference image,
replace that with its absolute value, then save that image to 
{\cf diff.tif}.


\subsection*{Changing the data format or bit depth}

Just use the {\cf -d} option to specify a pixel data format for all
subsequent outputs.  For example, assuming that {\cf in.tif} uses 16-bit
unsigned integer pixels, the following will convert it to an 8-bit
unsigned pixels:

\begin{code}
    oiiotool in.tif -d uint8 -o out.tif
\end{code}


\subsection*{Changing the compression}

The following command converts writes a TIFF file, specifically using
LZW compression:

\begin{code}
    oiiotool in.tif --compression lzw -o compressed.tif
\end{code}

The following command writes its results as a JPEG file at a 
compression quality of 50 (pretty severe compression):

\begin{code}
    oiiotool big.jpg --quality 50 -o small.jpg
\end{code}



\subsection*{Converting between scanline and tiled images}

Convert a scanline file to a tiled file with $16 \times 16$ tiles:

\begin{code}
    oiiotool s.tif --tile 16 16 -o t.tif
\end{code}

\noindent Convert a tiled file to scanline:

\begin{code}
    oiiotool t.tif --scanline -o s.tif
\end{code}



\subsection*{Adding captions or metadata}

\begin{code}
    oiiotool foo.jpg --caption "Hawaii vacation" -o bar.jpg
    oiiotool foo.jpg --keyword "volcano,lava" -o bar.jpg
    oiiotool in.exr --attrib "FStop" 22.0 -o out.exr
\end{code}


\subsection*{Scale the values in an image}

Reduce the brightness of the R, G, and B channels by 10%%,
but leave the A channel at its original value:

\begin{code}
    oiiotool original.exr --cmul 0.9,0.9,0.9,1.0 -o out.exr
\end{code}

\subsection*{Resize an image}

Resize by a known scale factor:

\begin{code}
    oiiotool original.tif --resize 200% -o big.tif
    oiiotool original.tif --resize 25% -o small.tif
\end{code}

\noindent Resize to a specific resolution:

\begin{code}
    oiiotool original.tif --resize 1024x768 -o specific.tif
\end{code}

\noindent Resize to fit into a given resolution, keeping the original
aspect ratio and padding with black where necessary:

\begin{code}
    oiiotool original.tif --fit 640x480 -o fit.tif
\end{code}


\subsection*{Color convert an image}

This command linearizes a JPEG assumed to be in sRGB, saving as
an HDRI OpenEXR file:

\begin{code}
    oiiotool photo.jpg --colorconvert sRGB linear -o output.exr
\end{code}

\noindent And the other direction:

\begin{code}
    oiiotool render.exr --colorconvert linear sRGB -o fortheweb.png
\end{code}

\noindent This converts between two named color spaces (presumably
defined by your facility's OpenColorIO configuration):

\begin{code}
    oiiotool in.dpx --colorconvert lg10 lnf -o out.exr
\end{code}


\subsection*{Channel reordering and padding}

\noindent Turn a single channel image into gray RGB:
\begin{code}
    oiiotool gray.tif --ch 0,0,0 -o rgb.tif
\end{code}

\noindent Copy just the color from an RGBA file, truncating the A,
yielding RGB only:
\begin{code}
    oiiotool rgba.tif --ch R,G,B -o rgb.tif
\end{code}

\noindent Zero out the red and green channels:
\begin{code}
    oiiotool rgb.tif --ch =0,=0,B -o justblue.tif
\end{code}

\noindent Swap the red and blue channels from an RGBA image:
\begin{code}
    oiiotool rgba.tif --ch 2,1,0,3 -o bgra.tif
\end{code}

\noindent Extract just the named channels from a complicted many-channel
image, and add an alpha channel that is 1 everywhere:
\begin{code}
    oiiotool allmyaovs.exr --ch spec.R,spec.G,spec.B,=1 -o spec.exr
\end{code}

\noindent Add a channel to an RGBA image, setting it to 3.0 everywhere,
and naming it ``Z'' so it will be recognized as a $z$ channel:
\begin{code}
    oiiotool rgba.exr --ch R,G,B,A,Z=3.0 -o rgbaz.exr
\end{code}


\subsection*{Composite a sequence of images}

\noindent Composite foreground images over background images for a
series of files with frame numbers in their names:
\begin{code}
    oiiotool fg.1-50#.exr bg.1-50#.exr --over -o comp.1-50#.exr
\end{code}

\noindent Or,
\begin{code}
    oiiotool --frames 1-50 fg.#.exr bg.#.exr --over -o comp.#.exr
\end{code}


\newpage
\section{\oiiotool commands: general}

\apiitem{--help}
Prints usage information to the terminal.
\apiend

\apiitem{-v}
Verbose status messages --- print out more information about what
\oiiotool is doing at every step.
\apiend

\apiitem{-q}
Quet mode --- print out less information about what \oiiotool is doing
(only errors).
\apiend

\apiitem{--runstats}
Print timing and memory statistics about the work done by \oiiotool.
\apiend

\apiitem{-a}
Performs all operations on all subimages and/or MIPmap levels of each
input image.  Without {\cf -a}, generally each input image will really
only read the top-level MIPmap of the first subimage of the file.
\apiend

\apiitem{--info}
Prints information about each input image as it is read.  If verbose mode
is turned on ({\cf -v}), all the metadata for the image is printed.
If verbose mode is not turned on, only the resolution and data format
are printed.
\apiend

\apiitem{--metamatch \emph{regex} \\
--no-metamatch \emph{regex}}
\NEW
Regular expressions to restrict which metadata are output when using
{\cf oiiotool --info -v}.  The {\cf --metamatch} expression causes only
metadata whose name matches to print; non-matches are not output.  The
{\cf --no-metamatch} expression causes metadata whose name matches to be
suppressed; others (non-matches) are printed.  It is not advised to use
both of these options at the same time (probably nothing bad will
happen, but it's hard to reason about the behavior in that case).
\apiend

\apiitem{--stats}
Prints detailed statistical information about each input image as it is
read.
\apiend

\apiitem{--hash}
Print the SHA-1 hash of the pixels of each input image.
\apiend

\apiitem{--diff}
This command computes the difference of the current image and the next
image on the stack, and prints a report of those differences (how
many pixels differed, the maximum amount, etc.).  This command does not
alter the image stack.
\apiend

\apiitem{--no-clobber}
Sets ``no clobber'' mode, in which existing images on disk will never be 
overridden, even if the {\cf -o} command specifies that file.
\apiend

\apiitem{--threads \emph{n}}
Use \emph{n} execution threads if it helps to speed up image operations.
The default (also if $n=0$) is to use as many threads as there are cores
present in the hardware.
\apiend

\apiitem{--frames \emph{seq}\\
--framepadding \emph{n}}
\NEW
Describes the frame range to substitute for the {\cf \#} wildcard.  The
sequence is a comma-separated list of subsequences; each subsequence
is a single frame (e.g., {\cf 100}), a range of frames ({\cf 100-150}),
or a frame range with step ({\cf 100-150x4} means {\cf  100,104,108,...}).

The frame padding is the number of digits (with leading zeroes applied)
that the frame numbers should have.  It defaults to 4.

For example,
\begin{code}
    oiiotool --framepadding 3 --frames 3,4,10-20x2 blah.#.tif
\end{code}
\noindent would match {\cf blah.003.tif}, {\cf blah.004.tif},
{\cf blah.010.tif}, {\cf blah.012.tif}, 
{\cf blah.014.tif}, {\cf blah.016.tif}, {\cf blah.018.tif}, 
{\cf blah.020.tif}.
\apiend

\begin{comment}
\apiitem{--inplace}
Causes the output to \emph{replace} the input file, rather than create a
new file with a different name.

Without this flag, \oiiotool expects two file names, which will
be used to specify the input and output files, respectively.

But when {\cf --inplace} option is used, any number of file names $\ge 1$ may
be specified, and the image conversion commands are applied to each file
in turn, with the output being saved under the original file name.  This
is useful for applying the same conversion to many files.  

For example, the following example will add the caption ``Hawaii
vacation'' to all JPEG files in the current directory:

\begin{code}
        oiiotool --inplace --adjust-time --caption "Hawaii vacation" *.jpg
\end{code}
\apiend
\end{comment}


\section{\oiiotool commands: reading and writing images}

The commands described in this section read images, write images,
or control the way that subsequent images will be written upon output.

\apiitem{\rm \emph{filename}}
If a command-line option is the name of an image file, that file will
be read and will become the new \emph{current image}, with the previous
current image pushed onto the image stack.
\apiend

\apiitem{-o \rm \emph{filename}}
Outputs the current image to the named file.  This does not remove the
current image, it merely saves a copy of it.
\apiend

\apiitem{-d {\rm \emph{datatype}}}

Attempts to set the pixel data type of all subsequent outputs.  Valid
choices are: {\cf uint8}, {\cf sint8}, 
{\cf uint16}, {\cf sint16}, {\cf  half}, {\cf float}, {\cf double}.

The types {\cf uint10} and {\cf uint12} may be used to request 10- or
12-bit unsigned integers.  If the output file format does not support
them, {\cf uint16} will be substituted.

If the {\cf -d} option is not supplied, the output data type will
be the same as the data format of the input files, if possible.

In any case, if the output file type does not support the requested
data type, it will instead use whichever supported data type results
in the least amount of precision lost.
\apiend

% FIXME -- no it doesn't!
%\apiitem{-g {\rm \emph{gamma}}}
%Applies a gamma correction of $1/\mathrm{gamma}$ to the pixels as they
%are output.
%\apiend

%\apiitem{--sRGB}
%Explicitly tags the image as being in sRGB color space.  Note that this
%does not alter pixel values, it only marks which color space those
%values refer to (and only works for file formats that understand such
%things).  An example use of this command is if you have an image 
%that is not explicitly marked as being in any particular color space,
%but you know that the values are sRGB.
%\apiend

\apiitem{--scanline}
Requests that subsequent output files be scanline-oriented, if scanline
orientation is supported by the output file format.  By default, the
output file will be scanline if the input is scanline, or tiled if the
input is tiled.
\apiend

\apiitem{--tile {\rm \emph{x}} {\rm \emph{y}}}
Requests that subsequent output files be tiled, with the given $x \times y$ 
tile size, if tiled images are supported by the output format.
By default, the output file will take on the tiledness and tile size
of the input file.
\apiend

\apiitem{--compression {\rm \emph{method}}}
Sets the compression method for subsequent output images.  Each
\ImageOutput plugin will have its own set of methods that it supports.
By default, the output image will use the same compression technique as
the input image (assuming it is supported by the output format,
otherwise it will use the default compression method of the output
plugin).  
\apiend

\apiitem{--quality {\rm \emph{q}}}
Sets the compression quality, on a 1--100 floating-point scale.
This only has an effect if the particular compression method supports
a quality metric (as JPEG does).
\apiend

\apiitem{--planarconfig {\rm \emph{config}}}
Sets the planar configuration of subsequent outputs (if supported by
their formats).  Valid choices are: {\cf config} for contiguous (or
interleaved) packing of channels in the file (e.g., RGBRGBRGB...), 
{\cf separate} for separate channel planes (e.g.,
RRRR...GGGG...BBBB...), or {\cf default} for the default choice for the
given format.  This command will be ignored for output files whose 
file format does not support the given choice.
\apiend

\apiitem{--adjust-time}
When this flag is present, after writing each output, the resulting
file's modification time will be adjusted to match any \qkw{DateTime}
metadata in the image.  After doing this, a directory listing will show
file times that match when the original image was created or captured,
rather than simply when \oiiotool was run.  This has no effect on
image files that don't contain any \qkw{DateTime} metadata.
\apiend

\apiitem{--noautocrop}
For subsequent outputs, do \emph{not} automatically crop images whose
formats don't support separate pixel data and full/display windows.
Without this, the default is that outputs will be cropped or padded with
black as necessary when written to formats that don't support the
concepts of pixel data windows and full/display windows.  This is a
non-issue for file formats that support these concepts, such as OpenEXR.
\apiend

\section{\oiiotool commands that change the current image metadata}

This section describes \oiiotool commands that alter the metadata
of the current image, but do not alter its pixel values.  Only the
current (i.e., top of stack) image is affected, not any images further
down the stack.

If the {\cf -a} flag has previously been set, these commands apply to
all subimages or MIPmap levels of the current top image.  Otherwise,
they only apply to the highest-resolution MIPmap level of the first
subimage of the current top image.

\apiitem{--attrib {\rm \emph{name value}}}
Adds or replaces metadata with the given \emph{name} to have the 
specified \emph{value}.

It will try to infer the type of the metadata from the value: if the
value contains only numerals (with optional leading minus sign), it will
be saved as {\cf int} metadata; if it also contains a decimal point, it
will be saved as {\cf float} metadata; otherwise, it will be saved as
a {\cf string} metadata.

For example, you could explicitly set the IPTC location metadata fields
with:
\begin{code}
        oiiotool --attrib "IPTC:City" "Berkeley" in.jpg out.jpg
\end{code}
\apiend

\apiitem{--sattrib {\rm \emph{name value}}}
Adds or replaces metadata with the given \emph{name} to have the 
specified \emph{value}, forcing it to be interpreted as a {\cf string}.
This is helpful if you want to set a {\cf string} metadata to a value
that the {\cf --attrib} command would normally interpret as a number.
\apiend

\apiitem{--caption {\rm \emph{text}}}
Sets the image metadata \qkw{ImageDescription}.
This has no effect if the output image format does not support some kind
of title, caption, or description metadata field.
Be careful to enclose \emph{text} in quotes if you want your caption to
include spaces or certain punctuation!
\apiend

\apiitem{--keyword {\rm \emph{text}}}
Adds a keyword to the image metadata \qkw{Keywords}.  Any existing
keywords will be preserved, not replaced, and the new keyword will not
be added if it is an exact duplicate of existing keywords.  This has no
effect if the output image format does not support some kind of keyword
field.  

Be careful to enclose \emph{text} in quotes if you want your keyword to
include spaces or certain punctuation.  For image formats that have only
a single field for keywords, \OpenImageIO will concatenate the keywords,
separated by semicolon (`;'), so don't use semicolons within your
keywords.
\apiend

\apiitem{--clear-keywords}
Clears all existing keywords in the current image.
\apiend

\apiitem{--orientation {\rm \emph{orient}}}
Explicitly sets the image's \qkw{Orientation} metadata to a numeric
value (see Section~\ref{metadata:orientation} for the numeric codes).
This only changes the metadata field that specifies
how the image should be displayed, it does NOT alter the pixels
themselves, and so has no effect for image formats that don't
support some kind of orientation metadata.
\apiend

\apiitem{--rotcw \\
--rotccw \\
--rot180}
Adjusts the image's \qkw{Orientation} metadata by rotating it $90^\circ$
clockwise, $90^\circ$ degrees counter-clockwise, or $180^\circ$,
respectively, compared to its current setting.  This only changes the
metadata field that specifies how the image should be displayed, it does
NOT alter the pixels themselves, and so has no effect for image formats
that don't support some kind of orientation metadata.
\apiend

\apiitem{--origin {\rm \emph{offset}}}
Set the pixel data window origin, essentially translating the existing
pixel data window to a different position on the image plane.
The offset is in the form
\begin{code}
     [+-]x[+-]y
\end{code}
\noindent Examples: 
\begin{code}
    --origin +20+10           x=20, y=10
    --origin +0-40            x=0, y=-40
\end{code}
\apiend

\apiitem{--fullsize {\rm \emph{size}}}
Set the display/full window size and/or offset.  The size is in the
form 
\\ \emph{width}\,{\cf x}\,\emph{height}{\cf [+-]}\emph{xoffset}{\cf
  [+-]}\emph{yoffset} \\
If either the offset or resolution is omitted, it will remain
unchanged.

\noindent Examples: 

\begin{tabular}{p{2in} p{4in}}
    {\cf --fullsize 1920x1080}  &      resolution w=1920, h=1080, offset unchanged \\
    {\cf --fullsize -20-30} &          resolution unchanged, x=-20, y=-30 \\
    {\cf --fullsize 1024x768+100+0}  & resolution w=1024, h=768, offset
    x=100, y=0
\end{tabular}

\apiend

\apiitem{--fullpixels}
Set the full/display window range to exactly cover the pixel data window.
\apiend

\apiitem{--chnames {\rm \emph{name-list}}}
Rename some or all of the channels of the top image to the given
comma-separated list.  Any completely empty channel names in the
list will not be changed.  For example,

\begin{code}
    oiiotool in.exr --chnames ",,,A,Z" -o out.exr
\end{code}

\noindent will rename channel 3 to be \qkw{A} and channel 4 to be
\qkw{Z}, but will leave channels 0--3 with their old names.
\apiend


\section{\oiiotool commands that adjust the image stack}

\apiitem{--pop}
Pop the image stack, discarding the current image and thereby
making the next image on the stack into the new current image.
\apiend

\apiitem{--dup}
Duplicate the current image and push the duplicate on the stack.
Note that this results in both the current and the next image 
on the stack being identical copies.
\apiend

\apiitem{--swap}
\NEW
Swap the current image and the next one on the stack.
\apiend

\apiitem{--ch {\rm \emph{channellist}}}
Replaces the top image with a new copy whose channels have been 
reordered as given by the \emph{channellist}.  The {\cf channellist}
is a comma-separated list of channel names and/or numbers (e.g., 
\qkw{R,G,B}, \qkw{A}, \qkw{B,G,R}, \qkw{4,5,6,A}).  Channel numbers outside
the valid range of input channels, or unknown names, will be replaced
by black channels.
\NEW A channel designation beginning with the {\cf =} character and followed
by a number is a \emph{literal value} that will be used to fill that
channel.  If the \emph{channellist} is shorter than the number of
channels in the source image, unspecified channels will be omitted.
\apiend

\apiitem{--chappend}
\NEW
Replaces the top two images on the stack with a new image comprised of
the channels of both images appended together.
\apiend

\apiitem{--selectmip {\rm \emph{level}}}
If the current image is MIP-mapped, replace the current image with a new
image consisting of only the given \emph{level} of the MIPmap.
Level 0 is the highest resolution version, level 1 is the next-lower
resolution version, etc.
\apiend

\apiitem{--unmip}
If the current image is MIP-mapped, discard all but the top level
(i.e., replacing the current image with a new image consisting of only the
highest-resolution level).  Note that this is equivalent to 
{\cf --selectmip 0}.
\apiend

\apiitem{--subimage {\rm \emph{n}}}
If the current image has multiple subimages, replace the current image
with a new image consisting of only the given subimage.
\apiend



\section{\oiiotool commands that make entirely new images}

\apiitem{--create {\rm \emph{size channels}}}

Create new black image with the given size and number of channels,
pushing it onto the image stack and making it the new current image.

The \emph{size} is in the form
\\ \emph{width}\,{\cf x}\,\emph{height}{\cf [+-]}\emph{xoffset}{\cf
  [+-]}\emph{yoffset} \\
If the offset is omitted, it will be $x=0,y=0$.

\noindent Examples:

\begin{tabular}{p{2in} p{4in}}
    {\cf --create 1920x1080 3}  &      RGB with w=1920, h=1080, x=0, y=0 \\
    {\cf --create 1024x768+100+0 4}  & RGBA with w=1024, h=768, x=100, y=0
\end{tabular}
\apiend


\apiitem{--pattern {\rm \emph{patternname size channels}}}
Create new image with the given size and number of channels,
initialize its pixels to the named pattern, and push it onto 
the image stack to make it the new current image.

The \emph{size} is in the form
\\ \emph{width}\,{\cf x}\,\emph{height}{\cf [+-]}\emph{xoffset}{\cf
  [+-]}\emph{yoffset} \\
If the offset is omitted, it will be $x=0,y=0$.

The patterns recognized include the following:

\begin{tabular}{p{1in} p{4in}}
    {\cf black}  & A black image (all pixels 0.0) \\
    {\cf constant}  & A constant color image, defaulting to white, but
       the color can be set with the optional {\cf :color=r,g,b,...}
       arguments giving a numerical value for each channel. \\
    {\cf checker} & A black and white checkerboard pattern.  The
       optional argument {\cf :width=} sets with width of the checkers
       (defaulting to 8 pixels).
\end{tabular}

\noindent Examples:

\apiitem{--pattern constant:color=0.3,0.5,0.1,1.0 640x480 4}
\vspace{10pt}
A constant 4-channel, $640\times 580$ image with all pixels (0.5, 0.5,
0.1, 1).
\apiend

\apiitem{--pattern checker:width=16 512x512 3}
\vspace{10pt}
An $512 \times 512$ RGB image with a 16-pixel-wide checker pattern.
\apiend

\apiend


\apiitem{--kernel {\rm \emph{name size}}}
\NEW
Create new 1-channel {\cf float} image big enough to hold the named
kernel and size (size is expressed as \emph{width}{\cf x}\emph{height},
e.g. {\cf 5x5}).  The \emph{width} and \emph{height} are allowed to be
floating-point numbers. The kernel image will have its origin offset so
that the kernel center is at (0,0), and and will be normalized (the sum
of all pixel values will be 1.0).

Kernel names can be: {\cf gaussian}, {\cf sharp-gaussian}, {\cf box},
{\cf triangle}, {\cf blackman-harris}, {\cf mitchell}, {\cf b-spline},
{\cf disk}.  There are also {\cf catmull-rom} and {\cf lanczos3}, but
they are fixed-size kernels that don't scale with the width, and are
therefore probably less useful in most cases.

\noindent Examples:

\begin{code}
    oiiotool --kernel gaussian 11x11 -o gaussian.exr
\end{code}
\apiend



\apiitem{--capture}

Capture a frame from a camera device, pushing it onto the image stack
and making it the new current image.  Optional appended arguments
include:

\begin{tabular}{p{10pt} p{1in} p{3.5in}}
  & {\cf camera=}\emph{num} & Select which camera number to capture
  (default: 0).
\end{tabular}

\noindent Examples:

\begin{tabular}{p{2in} p{4in}}
    {\cf --capture}  &      Capture from the default camera. \\
    {\cf --capture:camera=1}  & Capture from camera 2. \\
\end{tabular}
\apiend


\section{\oiiotool commands that do image processing}

\apiitem{--add}
Replace the \emph{two} top images with a new image that is the sum of
those images.
\apiend

\apiitem{--sub}
Replace the \emph{two} top images with a new image that is the difference
between the first and second images.
\apiend

\apiitem{--mul}
Replace the \emph{two} top images with a new image that the
pixel-by-pixel, channel-by-channel multiplicative product of
the first and second images.
\apiend

\apiitem{--abs}
Replace the current image with a new image that has each pixel
consisting of the \emph{absolute value} of he old pixel value.
\apiend

\apiitem{--cadd {\rm \emph{value}} \\
--cadd {\rm \emph{value0,value1,value2...}}}
\NEW
Add a constant value to all the pixels in the current image.  If a
single constant value is given, it will be added to all color channels.
Alternatively, a series of comma-separated constant values (with no
spaces!) may be used to specifiy a different value to add to each
channel in the image, respectively.
\apiend

\apiitem{--cmul {\rm \emph{value}} \\
--cmul {\rm \emph{value0,value1,value2...}}}
\NEW
Multiply all the pixel values in the top image by a constant value.
If a single constant value is given, all color channels will have their values
multiplied by the same value.  Alternatively, a series of
comma-separated constant values (with no spaces!) may be used to specifiy a
different multiplier for each channel in the image, respectively.
\apiend

\apiitem{--chsum}
\NEW
Replaces the top image by a copy that contains only 1 color channel,
whose value at each pixel is the sum of all channels of the original
image.  Using the optional {\cf weight} allows you to customize the
weight of each channel in the sum.

\begin{tabular}{p{10pt} p{1in} p{3.5in}}
  & {\cf weight=}\emph{r,g,...} & Specify the weight of each channel
  (default: 1).
\end{tabular}

\noindent Example:
\begin{code}
    oiiotool RGB.tif --chsum:weight=.2126,.7152,.0722 -o luma.tif
\end{code}
\apiend

\apiitem{--paste {\rm \emph{location}}}
\NEW
Takes two images -- the first is the ``foreground'' and the second is
the ``background'' -- and uses the pixels of the foreground to replace
those of the backgroud beginning at the upper left \emph{location}
(expressed as {\cf +}\emph{xpos}{\cf +}\emph{ypos}, e.g., {\cf +100+50},
or of course using {\cf -} for negative offsets).
\apiend

\apiitem{--mosaic {\rm \emph{size}}}
\NEW
Removes \emph{w}{\cf x}\emph{h} images, dictated by the
\emph{size}, and turns them into a single image mosaic.
Optional appended arguments
include:

\begin{tabular}{p{10pt} p{1in} p{3.5in}}
  & {\cf pad=}\emph{num} & Select the number of pixels of black padding
    to add between images (default: 0).
\end{tabular}

\noindent Examples:
\begin{code}
    oiiotool left.tif right.tif --mosaic:pad=16 2x1 -o out.tif

    oiiotool 0.tif 1.tif 2.tif 3.tif 4.tif --mosaic:pad=16 2x2 -o out.tif
\end{code}
\apiend

\apiitem{--over}
\index{composite}
Replace the \emph{two} top images with a new image that is the
Porter/Duff ``over'' composite with the first image as the foreground
and the second image as the background.
Both input images must have the same number and order of channels
and must contain an alpha channel.
\apiend

\apiitem{--zover}
\index{depth composite}
\NEW
Replace the \emph{two} top images with a new image that is a \emph{depth
composite} of the two images -- the operation is the 
Porter/Duff ``over'' composite, but each pixel individually will choose
which of the two images is the foreground and which background, depending on
the ``Z'' channel values for that pixel (larger Z means farther away).
Both input images must have the same number and order of channels
and must contain both depth/Z and alpha channels. Optional appended arguments
include:

\begin{tabular}{p{10pt} p{1in} p{3.5in}}
  & {\cf zeroisinf=}\emph{num} & If nonzero, indicates that $z=0$ pixels
  should be treated as if they were infinitely far away. (The default is
  0, meaning that ``zero means zero.'').
\end{tabular}

\apiend

\apiitem{--flip}
Replace the current image with a new image that is flipped vertically,
with the top scanline becoming the bottom, and vice versa.
\apiend

\apiitem{--flop}
Replace the current image with a new image that is flopped horizontally,
with the leftmost column becoming the rightmost, and vice versa.
\apiend

\apiitem{--flipflop}
Replace the current image with a new image that is both flipped and
flopped, which is the same as a 180 degree rotation.
\apiend

\apiitem{--transpose}
Replace the current image with a new image that is trasposed about
the $xy$ axis (x and coordinates and size are flipped).
\apiend

\apiitem{--cshift {\rm \emph{offset}}}
Circularly shift the pixels of the image by the given offset (expressed
as {\cf +10+100} to move by 10 pixels horizontally and 100 pixels
vertically, or {\cf +50-30} to move by 50 pixels horizontally and
$-30$ pixels vertically.  \emph{Circular} shifting means that the
pixels wrap to the other side as they shift.
\apiend

\apiitem{--crop {\rm \emph{size}}}
Replace the current image with a new copy with the given \emph{size},
cropping old pixels no longer needed, padding black pixels where they
previously did not exist in the old image, and adjusting the offsets
if requested.

The size is in the form 
\\ \spc\spc \emph{width}\,{\cf x}\,\emph{height}{\cf [+-]}\emph{xoffset}{\cf
  [+-]}\emph{yoffset}
\\ or~~~~ \spc \emph{xmin,ymin,xmax,ymax} \\

\noindent Examples: 

\begin{tabular}{p{2in} p{4in}}
    {\cf --crop 100x120+35+40}  &      resolution w=100, h=120, offset x=35, y=40 \\
    {\cf --crop 35,40,134,159}  &      resolution w=100, h=120, offset x=35, y=40
\end{tabular}
\apiend

\apiitem{--croptofull}
Replace the current image with a new image that is ropped or padded
as necessary to make the pixel data window exactly cover
the full/display window.
\apiend

\apiitem{--resample {\rm \emph{size}}}
\NEW
Replace the current image with a new image that is resampled to the
given pixel data resolution rapidly, but at a low quality, by simply
copying the ``closest'' pixel.  The \emph{size} is in the form 
\\ \spc\spc \emph{width}\,{\cf x}\,\emph{height}
\\ or~~~~ \spc \emph{scale}{\verb|%|} \\

\noindent Examples: 

\begin{tabular}{p{2in} p{4in}}
    {\cf --resample 1024x768}  &     new resolution w=100, h=120 \\
    {\cf --resample 50{\verb|%|}}  & reduce resolution to 50\verb|%| \\
    {\cf --resample 300{\verb|%|}}  & increase resolution by 3x
\end{tabular}

\apiend

\apiitem{--resize {\rm \emph{size}}}
Replace the current image with a new image that is resized to the 
given pixel data resolution.  The \emph{size} is in the form 
\\ \spc\spc \emph{width}\,{\cf x}\,\emph{height}
\\ or~~~~ \spc \emph{scale}{\verb|%|} \\

Optional appended arguments include:

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf filter=}\emph{name} & Filter name. The default is {\cf
  blackman-harris} when increasing resolution, {\cf lanczos3} when
decreasing resolution. \\
\end{tabular}

\noindent Examples: 

\begin{tabular}{p{2in} p{4in}}
    {\cf --resize 1024x768}  &     new resolution w=100, h=120 \\
    {\cf --resize 50{\verb|%|}}  & reduce resolution to 50\verb|%| \\
    {\cf --resize 300{\verb|%|}}  & increase resolution by 3x
\end{tabular}

\apiend

\apiitem{--fit {\rm \emph{size}}}
\NEW
Replace the current image with a new image that is resized to fit
into the given pixel data resolution, keeping the original aspect ratio
and padding with black pixels if the requested image size does not
have the same aspect ratio.  The \emph{size} is in the form 
\\ \spc\spc \emph{width}\,{\cf x}\,\emph{height}
\\ or~~~~ \spc \emph{width}\,{\cf x}\,\emph{height}{\cf [+-]}\emph{xorigin}{\cf [+-]}\emph{yorigin} \\

Optional appended arguments include:

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf filter=}\emph{name} & Filter name. The default is {\cf
  blackman-harris} when increasing resolution, {\cf lanczos3} when
decreasing resolution. \\
\end{tabular}
\apiend

\apiitem{--convolve}
\NEW
Use the top image as a kernel to convolve the next image farther down
the stack, replacing both with the result.

\noindent Examples:
\begin{code}
    # Use a kernel image already prepared
    oiiotool image.exr kernel.exr --convolve -o output.exr

    # Construct a kernel image on the fly with --kernel
    oiiotool image.exr --kernel gaussian 5x5 --convolve -o blurred.exr
\end{code}
\apiend

\apiitem{--blur {\rm \emph{size}}}
\NEW
Blur the top image with a blur kernel of the given size expressed as
\emph{width}{\cf x}\emph{height}.  (The sizes may be floating point 
numbers.)

Optional appended arguments include:

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf kernel=}\emph{name} & Kernel name. The default is {\cf
  gaussian}.
\end{tabular}

\noindent Examples:
\begin{code}
    oiiotool image.jpg --blur 5x5 -o blurred.jpg

    oiiotool image.jpg --blur:kernel=bspline 7x7 -o blurred.jpg
\end{code}
\apiend


\apiitem{--unsharp}
\NEW
Unblur the top image using an ``unsharp mask.'' 

Optional appended arguments include:

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf kernel=}\emph{name} & Name of the blur kernel (default: {\cf
    gaussian}). \\
 & {\cf width=}\emph{w} & Width of the blur kernel (default: 3). \\
 & {\cf contrast=}\emph{c} & Contrast scale (default: 1.0) \\
 & {\cf threshold=}\emph{t} & Threshold for applying the difference
  (default: 0)
\end{tabular}

\noindent Examples:
\begin{code}
    oiiotool image.jpg --unsharp -o sharper.jpg

    oiiotool image.jpg --unsharp:width=5:contrast=1.5 -o sharper.jpg
\end{code}
\apiend


\apiitem{--fft \\
--ifft}
\NEW
Performs forward and inverse unitized discrete Fourier transform.
The forward FFT always transforms only the first channel of the
top image on the stack, and results in a 2-channel image (with real and
imaginary channels).  The inverse FFT transforms the first two
channels of the top image on the stack (assuming they are real and
imaginary, respectively) and results in a single channel result (with
the real component only of the spatial domain result).

\noindent Examples:
\begin{code}
    # Select the blue channel and take its DCT
    oiiotool image.jpg --ch 2 --fft -o fft.exr

    # Reconstruct from the FFT
    oiiotool fft.exr --ifft -o reconstructed.exr

    # Output the power spectrum: real^2 + imag^2
    oiiotool fft.exr --dup --mul --chsum -o powerspectrum.exr
\end{code}
\apiend


\apiitem{--fixnan {\rm \emph{streategy}}}
Replace the top image with a copy in which any pixels that contained
{\cf NaN} or {\cf Inf} values (hereafter referred to collectively as
``nonfinite'') are repaired.  If \emph{strategy} is {\cf black},
nonfinite values will be replaced with {\cf 0}.  If \emph{strategy} is
{\cf box3}, nonfinite values will be replaced by the average of all the
finite values within a $3 \times 3$ region surrounding the pixel.
\apiend

\apiitem{--clamp}
\NEW
Replace the top image with a copy in which pixel values have been
clamped.  Optional arguments include:

Optional appended arguments include:

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf min=}\emph{val} & Specify a minimum value for all channels. \\
 & {\cf min=}\emph{val0,val1,...} & Specify minimum value for each 
                                    channel individually. \\
 & {\cf max=}\emph{val} & Specify a maximum value for all channels. \\
 & {\cf max=}\emph{val0,val1,...} & Specify maximum value for each 
                                    channel individually. \\
 & {\cf clampalpha=}\emph{val} & If \emph{val} is nonzero, will 
                                    additionally clamp the alpha channel
                                    to [0,1].  (Default: 0, no
                                    additional alpha clamp.)
\end{tabular}

If no value is given for either the minimum or maximum, it will NOT
clamp in that direction.  For the variety of minimum and maximum that
specify per-channel values, a missing value indicates that the
corresponding channel should not be clamped.  

\noindent Examples: 

\begin{tabular}{p{2in} p{4in}}
    {\cf --clamp:min=0} & Clamp all channels to a mimimum of 0 (all \\
                        &  negative values are changed to 0). \\
    {\cf --clamp:min=0:max=1} & Clamp all channels to [0,1]. \\
    {\cf --clamp:clampalpha=1} & Clamp the designated alpha channel to [0,1]. \\
    {\cf --clamp:min=,,0:max=,,3.0} & Clamp the third channel to [0,3],
                                      do not clamp \\ & other channels.
\end{tabular}

\apiend

\apiitem{--rangecompress \\
--rangeexpand}
\NEW
Range compression re-maps input values so that values $\le 1$ are
unchanged, and values $> 1$ are encoded on a logarithmic scale, with a
smooth transition between them.  Range expansion is the inverse
mapping.  Range compression and expansion only applies to color
channels; alpha or z channels will not be modified.

If the image has at least 3 channels and the first three channels are
not alpha or depth, they will be assumed to be RGB and the pixel scaling
will be done using the luminance and applied equally to all color
channels. This helps to preserve color even when remapping intensity.
If these conditions are not met, or if this behavior is explicitly
turned off with the optional {\cf luma=0} modifier, the remapping will
happen to each color channel independently.

Optional appended arguments include:

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf luma=}\emph{val} & If \emph{val} is 0, turns off the luma behavior.
\end{tabular}

Range compression and expansion can be useful in cases where high
contrast super-white ($> 1$) pixels (such as very bright highlights in
HDR captured or rendered images) can produce undesirable artifacts, such
as if you resize an HDR image using a filter with negative lobes --
which could result in objectionable ringing or even negative result
pixel values.  For example,

\begin{smallcode}
    oiiotool hdr.exr --rangecompress --resize 512x512 --rangeexpand -o resized.exr
\end{smallcode}
\apiend

\apiitem{--fillholes}
\NEW
Replace the top image with a copy in which any pixels that had
$\alpha < 1$ are ``filled'' in a smooth way using data from
surrounding $\alpha > 0$ pixels, resulting in an image that is
$\alpha = 1$ and plausible color everywhere.
This can be used both to fill internal ``holes'' as well as to extend an
image out.
\apiend


\apiitem{--text {\rm \emph{words}}}
Draw (rasterize) text overtop of the current image.

\begin{tabular}{p{10pt} p{1in} p{3.75in}}
 & {\cf x=}\emph{xpos} & $x$ position (in pixel coordinates) of the text \\
 & {\cf y=}\emph{ypos} & $y$ position (in pixel coordinates) of the text  \\
 & {\cf size=}\emph{size} & font size (height, in pixels) \\
 & {\cf font=}\emph{name} & font name, full path to the font file on
  disk (use double quotes {\cf "name"} if the path name includes spaces) \\
 & {\cf color=}\emph{r,g,b,...} & specify the color of the text \\
\end{tabular}

The default positions the text starting at the center of the image,
drawn 16 pixels high in opaque white in all channels (1,1,1,...), and
using a default font (which may be system dependent).

\noindent Examples: 

\begin{code}
    oiiotool in.exr --text:x=10:y=400:size=40 "Hello world" -o out.exr
\end{code}

\apiend



\section{\oiiotool commands for color management}

\apiitem{--iscolorspace {\rm \emph{colorspace}}}
Alter the metadata of the current image so that it thinks its pixels
are in the named color space.  This does not alter the pixels of the
image, it only changes \oiiotool's understanding of what color
space those those pixels are in.
\apiend

\apiitem{--tocolorspace {\rm \emph{tospace}}}
Replace the current image with a new image whose pixels are transformed
from their existing color space (as best understood or guessed by OIIO)
into the named \emph{tospace}.
\apiend

\apiitem{--colorconvert {\rm \emph{fromspace tospace}}}
Replace the current image with a new image whose pixels are transformed
from the named \emph{fromspace} color space into the named
\emph{tospace} (disregarding any notion it may have previously had 
about the color space of the current image).
\apiend

\apiitem{--unpremult}
\NEW
Divide all color channels (those not alpha or z) of the current image by
the alpha value, to ``un-premultiply'' them.  This presumes that the
image starts of as ``associated alpha,'' a.k.a.\ ``premultipled.''
Pixels in which the alpha channel is 0 will not be modified (since the
operation is undefined in that case).  This is a no-op if there is no
identified alpha channel.
\apiend

\apiitem{--premult}
\NEW
Multiply all color channels (those not alpha or z) of the current image
by the alpha value, to ``premultiply'' them.  This presumes that the
image starts of as ``unassociated alpha,'' a.k.a.\ ``non-premultipled.''
\apiend


